QUES 1 [Implement Stack using Arrays]

class myStack {

    int[] arr;     
    int top;       
    int capacity;  
    public myStack(int n) {
        capacity = n;
        arr = new int[n];
        top = -1;
    }

    public boolean isEmpty() {
        return (top == -1);
    }

    public boolean isFull() {
        return (top == capacity - 1);
    }

    public void push(int x) {
        if (!isFull()) {
            arr[++top] = x;
        }
    }

    public void pop() {
        if (!isEmpty()) {
            top--;
        }
    }

    // Peek operation
    public int peek() {
        if (!isEmpty()) {
            return arr[top];
        }
        return -1;  
    }
}


QUES 2 [Implement Queue using Arrays]

class myQueue {

    int[] arr;
    int front;
    int rear;
    int size;
    int capacity;

    public myQueue(int n) {
        capacity = n;
        arr = new int[n];
        front = 0;
        rear = -1;
        size = 0;
    }

    public boolean isEmpty() {
        return (size == 0);
    }

    public boolean isFull() {
        return (size == capacity);
    }

    public void enqueue(int x) {
        if (!isFull()) {
            rear = (rear + 1) % capacity;
            arr[rear] = x;
            size++;
        }
    }

    public void dequeue() {
        if (!isEmpty()) {
            front = (front + 1) % capacity;
            size--;
        }
    }

    public int getFront() {
        if (!isEmpty()) {
            return arr[front];
        }
        return -1;
    }

    public int getRear() {
        if (!isEmpty()) {
            return arr[rear];
        }
        return -1;
    }
}


QUES 3 [Implement Stack using LL]

class myStack {

    private class Node {
        int data;
        Node next;
        Node(int d) {
            data = d;
            next = null;
        }
    }

    private Node top;
    private int count;

    public myStack() {
        top = null;
        count = 0;
    }

    public void push(int x) {
        Node newNode = new Node(x);
        newNode.next = top;
        top = newNode;
        count++;
    }

    public void pop() {
        if (!isEmpty()) {
            top = top.next;
            count--;
        }
    }

    public int peek() {
        if (!isEmpty()) {
            return top.data;
        }
        return -1;
    }

    public boolean isEmpty() {
        return top == null;
    }

    public int size() {
        return count;
    }
}


QUES 4 [Implement Queue using LL]

class myQueue {

    private class Node {
        int data;
        Node next;
        Node(int d) {
            data = d;
            next = null;
        }
    }

    private Node front;
    private Node rear;
    private int count;

    public myQueue() {
        front = null;
        rear = null;
        count = 0;
    }
    public void enqueue(int x) {
        Node newNode = new Node(x);
        if (rear != null) {
            rear.next = newNode;
        }
        rear = newNode;
        if (front == null) {
            front = rear;
        }
        count++;
    }
    public void dequeue() {
        if (!isEmpty()) {
            front = front.next;
            if (front == null) {
                rear = null;
            }
            count--;
        }
    }

    public int getFront() {
        if (!isEmpty()) {
            return front.data;
        }
        return -1;
    }

    public boolean isEmpty() {
        return front == null;
    }
    public int size() {
        return count;
    }
}

QUES 5 [Valid Parentheses]

class Solution {
  public boolean isValid(String s) {
    Deque<Character> stack = new ArrayDeque<>();

    for (final char c : s.toCharArray())
      if (c == '(')
        stack.push(')');
      else if (c == '{')
        stack.push('}');
      else if (c == '[')
        stack.push(']');
      else if (stack.isEmpty() || stack.pop() != c)
        return false;

    return stack.isEmpty();
  }
}

QUES 6 [Prefix to Infix]

import java.util.*;

class Solution {

    public String preToInfix(String prefix) {
        Stack<String> stack = new Stack<>();

        for (int i = prefix.length() - 1; i >= 0; i--) {
            char c = prefix.charAt(i);

            if (Character.isLetter(c)) {
                stack.push(c + "");
            } else { 
                String op1 = stack.pop();
                String op2 = stack.pop();
                String exp = "(" + op1 + c + op2 + ")";
                stack.push(exp);
            }
        }

        return stack.pop();
    }
}


QUES 7 [Prefix to Postfix]

import java.util.*;

class Solution {
    public String preToPost(String pre_exp) {
        Stack<String> stack = new Stack<>();

        for (int i = pre_exp.length() - 1; i >= 0; i--) {
            char c = pre_exp.charAt(i);

            if (Character.isLetter(c)) {
                stack.push(c + "");
            } else {
                String op1 = stack.pop();
                String op2 = stack.pop();
                String exp = op1 + op2 + c;
                stack.push(exp);
            }
        }

        return stack.pop();
    }
}


QUES 8 [Postfix to Infix]

import java.util.*;

class Solution {
    public String postToInfix(String post_exp) {
        Stack<String> stack = new Stack<>();

        for (int i = 0; i < post_exp.length(); i++) {
            char c = post_exp.charAt(i);

            if (Character.isLetter(c)) {
                stack.push(c + "");
            } else {
                String op2 = stack.pop();
                String op1 = stack.pop();
                String exp = "(" + op1 + c + op2 + ")";
                stack.push(exp);
            }
        }

        return stack.pop();
    }
}


QUES 9 [Next Greater Element]

class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Stack<Integer> stack = new Stack<>();        
        Map<Integer, Integer> nextGreater = new HashMap<>();
        for (int num : nums2) {
           
            while (!stack.isEmpty() && num > stack.peek()) {
                nextGreater.put(stack.pop(), num);
            }
            stack.push(num);
        }

        while (!stack.isEmpty()) {
            nextGreater.put(stack.pop(), -1);
        }

        int[] result = new int[nums1.length];
        for (int i = 0; i < nums1.length; i++) {
            result[i] = nextGreater.get(nums1[i]);
        }

        return result;
    
    
    }
}

QUES 11 [First negative in window of size k]

import java.util.*;

class Solution {
    public List<Integer> firstNegInt(int[] arr, int k) {
        List<Integer> result = new ArrayList<>();
        Deque<Integer> q = new LinkedList<>();
        int n = arr.length;

        for (int i = 0; i < k; i++) {
            if (arr[i] < 0) q.addLast(i);
        }

        for (int i = k; i < n; i++) {
            if (!q.isEmpty()) result.add(arr[q.peekFirst()]);
            else result.add(0);

            while (!q.isEmpty() && q.peekFirst() <= i - k) q.pollFirst();
            if (arr[i] < 0) q.addLast(i);
        }

        if (!q.isEmpty()) result.add(arr[q.peekFirst()]);
        else result.add(0);

        return result;
    }
}


QUES 12 [Reverse first K of a Queue]

import java.util.*;

class Solution {
    public Queue<Integer> reverseFirstK(Queue<Integer> q, int k) {
        if (q.size() < k) return q;

        Stack<Integer> stack = new Stack<>();

        for (int i = 0; i < k; i++) {
            stack.push(q.poll());
        }

        while (!stack.isEmpty()) {
            q.add(stack.pop());
        }

        int size = q.size();
        for (int i = 0; i < size - k; i++) {
            q.add(q.poll());
        }

        return q;
    }
}


QUES 13 [Generate Binary Numbers]

import java.util.*;

class Solution {
    public ArrayList<String> generateBinary(int n) {
        ArrayList<String> result = new ArrayList<>();
        Queue<String> q = new LinkedList<>();

        q.add("1");

        for (int i = 0; i < n; i++) {
            String s = q.poll();
            result.add(s);

            q.add(s + "0");
            q.add(s + "1");
        }

        return result;
    }
}


QUES 14 [Implement Stack using Queue]

import java.util.*;

class MyStack {
    private Queue<Integer> q1;
    private Queue<Integer> q2;

    public MyStack() {
        q1 = new LinkedList<>();
        q2 = new LinkedList<>();
    }

    public void push(int x) {
        q2.add(x);
        while (!q1.isEmpty()) {
            q2.add(q1.poll());
        }
        // Swap q1 and q2
        Queue<Integer> temp = q1;
        q1 = q2;
        q2 = temp;
    }

    public int pop() {
        return q1.poll();
    }

    public int top() {
        return q1.peek();
    }

    public boolean empty() {
        return q1.isEmpty();
    }
}


QUES 15 [Implement Queue using Stack]

import java.util.*;

class MyQueue {
    private Stack<Integer> inStack;
    private Stack<Integer> outStack;

    public MyQueue() {
        inStack = new Stack<>();
        outStack = new Stack<>();
    }

    public void push(int x) {
        inStack.push(x);
    }

    public int pop() {
        if (outStack.isEmpty()) {
            while (!inStack.isEmpty()) {
                outStack.push(inStack.pop());
            }
        }
        return outStack.pop();
    }

    public int peek() {
        if (outStack.isEmpty()) {
            while (!inStack.isEmpty()) {
                outStack.push(inStack.pop());
            }
        }
        return outStack.peek();
    }

    public boolean empty() {
        return inStack.isEmpty() && outStack.isEmpty();
    }
}


QUES 16 [Min Stack]

import java.util.*;

class MinStack {
    private Stack<Integer> stack;
    private Stack<Integer> minStack;

    public MinStack() {
        stack = new Stack<>();
        minStack = new Stack<>();
    }
    
    public void push(int val) {
        stack.push(val);
        if (minStack.isEmpty() || val <= minStack.peek()) {
            minStack.push(val);
        }
    }
    
    public void pop() {
        if (!stack.isEmpty()) {
            int val = stack.pop();
            if (val == minStack.peek()) {
                minStack.pop();
            }
        }
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return minStack.peek();
    }
}


QUES 17 [Next smaller]

import java.util.*;

public class Solution {
    public ArrayList<Integer> nextSmallerEle(int[] arr) {
        int n = arr.length;
        ArrayList<Integer> nse = new ArrayList<>();
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < n; i++) nse.add(-1);

        for (int i = n - 1; i >= 0; i--) {
            while (!stack.isEmpty() && stack.peek() >= arr[i]) {
                stack.pop();
            }
            if (!stack.isEmpty()) nse.set(i, stack.peek());
            stack.push(arr[i]);
        }
        return nse;
    }
}


QUES 18 [Largest Rectangke in Histogram]

class Solution {
  public int largestRectangleArea(int[] heights) {
    int ans = 0;
    Deque<Integer> stack = new ArrayDeque<>();

    for (int i = 0; i <= heights.length; ++i) {
      while (!stack.isEmpty() && (i == heights.length || heights[stack.peek()] > heights[i])) {
        final int h = heights[stack.pop()];
        final int w = stack.isEmpty() ? i : i - stack.peek() - 1;
        ans = Math.max(ans, h * w);
      }
      stack.push(i);
    }

    return ans;
  }
}

QUES 19 [Design Twitter]

class Twitter {
     private static class Tweet {
        int id;
        int time;
        Tweet(int id, int time) {
            this.id = id;
            this.time = time;
        }
    }
     private Map<Integer, Set<Integer>> followers;
     private Map<Integer, List<Tweet>> tweets;
     private int timestamp;

    public Twitter() {
        followers = new HashMap<>();
        tweets = new HashMap<>();
        timestamp = 0;
        
    }
    
    public void postTweet(int userId, int tweetId) {
         tweets.putIfAbsent(userId, new ArrayList<>());
        tweets.get(userId).add(new Tweet(tweetId, timestamp++));
        
    }
    
    public List<Integer> getNewsFeed(int userId) {
        PriorityQueue<Tweet> maxHeap = new PriorityQueue<>((a, b) -> b.time - a.time);
        if (tweets.containsKey(userId)) {
            maxHeap.addAll(tweets.get(userId));
        }
        if (followers.containsKey(userId)) {
            for (int followeeId : followers.get(userId)) {
                if (tweets.containsKey(followeeId)) {
                    maxHeap.addAll(tweets.get(followeeId));
                }
            }
        }
        List<Integer> feed = new ArrayList<>();
        int count = 0;
        while (!maxHeap.isEmpty() && count < 10) {
            feed.add(maxHeap.poll().id);
            count++;
        }
        return feed;
    }
    
    public void follow(int followerId, int followeeId) {
        if (followerId == followeeId) return; // cannot follow self
        followers.putIfAbsent(followerId, new HashSet<>());
        followers.get(followerId).add(followeeId);
        
    }
    
    public void unfollow(int followerId, int followeeId) {
        if (followers.containsKey(followerId)) {
            followers.get(followerId).remove(followeeId);
        }
    }
}



QUES 20 [Maximal Rectangle]

class Solution {
  public int maximalRectangle(char[][] matrix) {
    if (matrix.length == 0)
      return 0;

    int ans = 0;
    int[] hist = new int[matrix[0].length];

    for (char[] row : matrix) {
      for (int i = 0; i < row.length; ++i)
        hist[i] = row[i] == '0' ? 0 : hist[i] + 1;
      ans = Math.max(ans, largestRectangleArea(hist));
    }

    return ans;
  }

  private int largestRectangleArea(int[] heights) {
    int ans = 0;
    Deque<Integer> stack = new ArrayDeque<>();

    for (int i = 0; i <= heights.length; ++i) {
      while (!stack.isEmpty() && (i == heights.length || heights[stack.peek()] > heights[i])) {
        final int h = heights[stack.pop()];
        final int w = stack.isEmpty() ? i : i - stack.peek() - 1;
        ans = Math.max(ans, h * w);
      }
      stack.push(i);
    }

    return ans;
  }
}


QUES 21 [ 2142 - C]

import java.util.Scanner;

public class BrokenKeyboard {
    
    public static String processKeypresses(String s) {
        StringBuilder result = new StringBuilder();
        
        for (char ch : s.toCharArray()) {
            if (ch == 'b') {
                for (int i = result.length() - 1; i >= 0; i--) {
                    if (Character.isLowerCase(result.charAt(i))) {
                        result.deleteCharAt(i);
                        break;
                    }
                }
            } else if (ch == 'B') {
                // Remove last uppercase letter
                for (int i = result.length() - 1; i >= 0; i--) {
                    if (Character.isUpperCase(result.charAt(i))) {
                        result.deleteCharAt(i);
                        break;
                    }
                }
            } else {
                result.append(ch);
            }
        }
        
        return result.toString();
    }

}

